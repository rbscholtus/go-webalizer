// Code generated by ldetool cmd/goAnalyzer/clf.lde --package main. DO NOT EDIT.

package main

import (
	"bytes"
	"fmt"
	"strconv"
	time "time"
	"unsafe"
)

var constLogEntrySpaceBslash = []byte(" \"")

// LogEntry ...
type LogEntry struct {
	Rest      []byte
	IP        string
	Identity  []byte
	User      []byte
	Timestamp time.Time
	Method    string
	URLPath   string
	Version   []byte
	RespCode  uint16
	Size      uint64
	Referrer  string
	UserAgent string
}

// Extract ...
func (p *LogEntry) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos, posQ int
	var tmp []byte
	var tmpUint uint64

	// Take until ' ' as IP($string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.IP, err = p.unmarshalIP(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field IP(string): %s", string(tmp), err)
	}

	// Take until ' ' as Identity(string)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Identity = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ' ' as User(string)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.User = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with '[' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == '[' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ']' as Timestamp(time.Time)
	pos = bytes.IndexByte(p.Rest, ']')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.Timestamp, err = p.unmarshalTimestamp(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Timestamp(time.Time): %s", string(tmp), err)
	}

	// Checks if the rest starts with `" \""` and pass it
	if bytes.HasPrefix(p.Rest, constLogEntrySpaceBslash) {
		p.Rest = p.Rest[len(constLogEntrySpaceBslash):]
	} else {
		return false, nil
	}

	// Take until ' ' as Method($string)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.Method, err = p.unmarshalMethod(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Method(string): %s", string(tmp), err)
	}

	// Take until ' ' or '"' as URLPath($string)
	posQ = bytes.IndexByte(p.Rest, '"')
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos > 0 && pos < posQ {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else if posQ > 0 && posQ < pos {
		tmp = p.Rest[:posQ]
		p.Rest = p.Rest[posQ:]
	} else {
		return false, nil
	}
	if p.URLPath, err = p.unmarshalURLPath(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field URLPath(string): %s", string(tmp), err)
	}

	// Take until '"' as Version(string)
	pos = bytes.IndexByte(p.Rest, '"')
	if pos >= 0 {
		p.Version = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == ' ' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as RespCode(uint16)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field RespCode(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.RespCode = uint16(tmpUint)

	// Take until ' ' (or all the rest if not found) as Size($uint64)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		tmp = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}
	if p.Size, err = p.unmarshalSize(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Size(uint64): %s", string(tmp), err)
	}

	// Checks if the rest starts with '"' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == '"' {
		p.Rest = p.Rest[1:]
	} else {
		p.Referrer = ""
		p.UserAgent = ""
		return true, nil
	}

	// Take until '"' as Referrer($string)
	pos = bytes.IndexByte(p.Rest, '"')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.Referrer, err = p.unmarshalReferrer(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Referrer(string): %s", string(tmp), err)
	}

	// Checks if the rest starts with `" \""` and pass it
	if bytes.HasPrefix(p.Rest, constLogEntrySpaceBslash) {
		p.Rest = p.Rest[len(constLogEntrySpaceBslash):]
	} else {
		return false, nil
	}

	// Take until '"' as UserAgent($string)
	pos = bytes.IndexByte(p.Rest, '"')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.UserAgent, err = p.unmarshalUserAgent(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field UserAgent(string): %s", string(tmp), err)
	}

	return true, nil
}
