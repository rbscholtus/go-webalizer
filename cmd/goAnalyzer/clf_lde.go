// Code generated by ldetool cmd/goAnalyzer/clf.lde --package main. DO NOT EDIT.

package main

import (
	"bytes"
	"fmt"
	"os"
	"strconv"
	time "time"
	"unsafe"
)

var (
	constSpaceLBracket = []byte(" [")
	constSpaceDQuote   = []byte(` "`)
	constHttpPrefix    = []byte(" HTTP/")
	constDQuoteSpace   = []byte(`" `)
)

// LogEntry ...
type LogEntry struct {
	Rest      []byte
	IP        string
	Identity  []byte
	User      []byte
	Timestamp time.Time
	Method    string
	URLPath   string
	Version   []byte
	RespCode  uint16
	Size      uint64
	Referrer  string
	UserAgent string
}

// Extract ...
func (p *LogEntry) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64
	var ch byte

	// Take until ' ' as IP($string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.IP, err = p.unmarshalIP(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field IP(string): %s", string(tmp), err)
	}

	// Take until ' ' as Identity(string)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Identity = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ' [' as User(string)
	pos = bytes.Index(p.Rest, constSpaceLBracket)
	if pos > 0 {
		p.User = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constSpaceLBracket):]
	} else {
		return false, nil
	}

	// Take until ']' as Timestamp(time.Time)
	pos = bytes.IndexByte(p.Rest, ']')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.Timestamp, err = p.unmarshalTimestamp(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Timestamp(time.Time): %s", string(tmp), err)
	}

	// Checks if the rest starts with ` "` and pass it
	if bytes.HasPrefix(p.Rest, constSpaceDQuote) {
		p.Rest = p.Rest[len(constSpaceDQuote):]
	} else {
		return false, nil
	}

	// Take [A-Z]{3,10} delimited by ' ' as Method(string)
	for pos, ch = range p.Rest {
		if ch == ' ' {
			if pos >= 3 {
				p.Method = string(p.Rest[:pos])
				p.Rest = p.Rest[pos+1:]
			} else {
				p.Method = "-"
			}
			break
		} else if pos >= 10 {
			p.Method = "-"
			break
		} else if ch < 'A' || ch > 'Z' {
			p.Method = "-"
			break
		}
	}

	// Take until ' HTTP/' or '" ' as URLPath($string)
	pos = bytes.Index(p.Rest, constHttpPrefix)
	if pos > 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else if pos = bytes.Index(p.Rest, constDQuoteSpace); pos > 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos:]
	} else {
		return false, nil
	}
	if p.URLPath, err = p.unmarshalURLPath(tmp); err != nil {
		// pass with Unescape error
		fmt.Fprintf(os.Stderr, "Warning: parsing `%s` into field URLPath(string): %s\n", string(tmp), err)
		// return false, fmt.Errorf("parsing `%s` into field URLPath(string): %s", string(tmp), err)
	}

	// Take until '"' as Version(string)
	pos = bytes.IndexByte(p.Rest, '"')
	if pos >= 0 {
		p.Version = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == ' ' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as RespCode(uint16)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field RespCode(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.RespCode = uint16(tmpUint)

	// Take until ' ' (or all the rest if not found) as Size($uint64)
	pos = -1
	for i, char := range p.Rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		tmp = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}
	if p.Size, err = p.unmarshalSize(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Size(uint64): %s", string(tmp), err)
	}

	// Checks if the rest starts with '"' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == '"' {
		p.Rest = p.Rest[1:]
	} else {
		p.Referrer = ""
		p.UserAgent = ""
		return true, nil
	}

	// Take until '"' as Referrer($string)
	pos = bytes.IndexByte(p.Rest, '"')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.Referrer, err = p.unmarshalReferrer(tmp); err != nil {
		// pass with Unescape error
		fmt.Fprintf(os.Stderr, "Warning: parsing `%s` into field Referrer(string): %s\n", string(tmp), err)
		// return false, fmt.Errorf("parsing `%s` into field Referrer(string): %s", string(tmp), err)
	}

	// Checks if the rest starts with `" \""` and pass it
	if bytes.HasPrefix(p.Rest, constSpaceDQuote) {
		p.Rest = p.Rest[len(constSpaceDQuote):]
	} else {
		return false, nil
	}

	// Take until '"' as UserAgent($string)
	pos = bytes.IndexByte(p.Rest, '"')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.UserAgent, err = p.unmarshalUserAgent(tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field UserAgent(string): %s", string(tmp), err)
	}

	return true, nil
}
